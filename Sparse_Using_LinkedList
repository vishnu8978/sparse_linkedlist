#include <iostream>
#include <iomanip>

// The below is the node structure of linked list
struct Node {
    int row, col, value;
    Node* next;
    Node(int r, int c, int v) : row(r), col(c), value(v), next(nullptr) {}
};

class SparseMatrix {
private:
    Node* start;
    int numRows, numCols;

public:
    SparseMatrix(int rows, int cols) : start(nullptr), numRows(rows), numCols(cols) {}

    // Inserting or updating new element to sparse matrix
    void addElement(int row, int col, int value) {
        if (value == 0) return; // Don't add zero elements

        Node* newNode = new Node(row, col, value);
        if (!start || row < start->row || (row == start->row && col < start->col)) {
            newNode->next = start;
            start = newNode;
        } else {
            Node* current = start;
            while (current->next && (current->next->row < row || 
                   (current->next->row == row && current->next->col < col))) {
                current = current->next;
            }
            newNode->next = current->next;
            current->next = newNode;
        }
    }

    // Here below is representation of sparse matrix in linked list format
    void display() const {
        std::cout << "Sparse Matrix Representation (Linked List):\n";
        Node* current = start;
        while (current) {
            std::cout << "[" << current->row << " " << current->col << " " << current->value << "]";
            if (current->next) {
                std::cout << " -> ";
            } else {
                std::cout << " -> NULL";
            }
            current = current->next;
        }
        std::cout << std::endl;
    }

    // Here we are displaying the original matrix
    void displayOriginal() const {
        int** matrix = new int*[numRows];
        for (int i = 0; i < numRows; ++i) {
            matrix[i] = new int[numCols]();
        }

        Node* current = start;
        while (current) {
            matrix[current->row][current->col] = current->value;
            current = current->next;
        }

        std::cout << "Representation of Original Matrix:\n";
        for (int i = 0; i < numRows; ++i) {
            for (int j = 0; j < numCols; ++j) {
                std::cout << std::setw(2) << matrix[i][j] << " ";
            }
            std::cout << "\n";
        }

       
        for (int i = 0; i < numRows; ++i) {
            delete[] matrix[i];
        }
        delete[] matrix;
    }

    // Here destructor is created to free allocated memory
    ~SparseMatrix() {
        Node* current = start;
        while (current) {
            Node* next = current->next;
            delete current;
            current = next;
        }
    }
};

int main() {
    // The below are the random dimensions of sparse matrix
    SparseMatrix sparseMatrix(4, 5);

    sparseMatrix.addElement(0, 2, 3);
    sparseMatrix.addElement(0, 4, 4);
    sparseMatrix.addElement(1, 2, 5);
    sparseMatrix.addElement(1, 3, 7);
    sparseMatrix.addElement(3, 1, 2);
    sparseMatrix.addElement(3, 2, 6);

    // Here this function will display original representation of matrix usually before converting to sparse representation.
    sparseMatrix.displayOriginal();

    std::cout << "\n";

    // Below function will display representation of converted sparse matrix
    sparseMatrix.display();

    return 0;
}
